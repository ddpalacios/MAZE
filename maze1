#include <stdio.h>
#include <string.h>
#define SIZE 1000

int loadFile(char* filename);
int getRowCount(FILE* fp);
int getColCount(FILE* fp);
void CreateGrid(char* filename,FILE* fp, int rowCount, int colNum);
void enQueue(int);
void deQueue();
void display();
void solve(FILE* fp,int xstart, int ystart, int colNum, int rowCount);
int items[SIZE], front = -1, rear = -1;
struct node {
        int data;
        struct node *next;
    } *head, *temp, *curr, *left;


int main(void) {
    
loadFile("maze.txt");



return 0;
}



int loadFile(char* filename)
{
     
     FILE *fp;
     fp = fopen(filename, "r");
      if (fp == NULL){
        printf("Could not open file %s",filename);
        return 0;
    }
    else{
        printf("FILE LOADED...\n\n");
        int colNum = getColCount(fp);
        int rowCount = getRowCount(fp);
        fclose(fp); //close file
        fp = fopen(filename, "r");   //reopen
        CreateGrid(filename,fp, rowCount, colNum);
        
       
        
        
        
        return 0;
        
    }
    
    
    
    
}
int getColCount(FILE* fp)
{
    char col[200];
     int colNum;
     
    fscanf(fp,"%[^\n]", col);
    colNum = strlen(col) +1; //get total col count
       
       
return colNum;    
    
}
int getRowCount(FILE* fp)
{
     char c;
     int Rowcount =1;
     
     for (c = getc(fp); c != EOF; c = getc(fp)) {
        if (c == '\n'){ // Increment count if this character is newline 
            Rowcount = Rowcount + 1; 
        }
}
return Rowcount;
    
    
}
void CreateGrid(char* filename, FILE* fp, int rowCount, int colNum)
{
    int i, j;
    int startPos[2];
   
     
     int dimensions[rowCount][colNum];
        
        for (i = 0; i < rowCount; i++) {
           
             for (j = 0; j < colNum; j++) {
                    char brick = getc(fp);
                   dimensions[i][j] = brick;
                   
                   
                   if (brick == 's'){
                      
                       startPos[0] = i;
                       startPos[1] = j;

                   }
                    printf("%c", dimensions[i][j]);
        }
        
        
        
      
    }
    fclose(fp); //close file
    fp = fopen(filename, "r");   //reopen
   solve(fp, startPos[0], startPos[1], colNum, rowCount);
    

}



void solve(FILE* fp,int xstart, int ystart, int colNum, int rowCount)
{
    
     int i, j;
  for (i = 0; i < rowCount; i++) {
            deleteAll();
           
             for (j = 0; j < colNum; j++) {
                 char graphNode = getc(fp);
               
                 if (graphNode == ' '){
                     add(NULL); //null value set to zero
                     append(j); //appends front of Linked List
                     delete(0); //removes null 0 value
                     
                 }
                 
    
    
             }
            printf("\nRow [%d] -> ", i);
            disp(); //displays linked list
      
  }
    
}







//Linked List implementation
void add(int num) {
        int i=0;
        temp = (struct node *) malloc(sizeof(struct node));
        temp->data = num;
 
            if(head == NULL) {
                head = temp;
                head->next = NULL;
            }
            else
            {
                temp->next = head;                
                head = temp;
            }
 
    }
void append(int data) {
 
        temp = (struct node *) malloc(sizeof(struct node));
        temp->data = data;
        curr = head;
 
        if(curr == NULL) {
            head = temp; 
            head->next = NULL;
        }
         
        while(curr->next != NULL) {
            curr = curr->next;
        }
        curr->next = temp;
        curr = temp;
        curr->next = NULL;
    }
void delete(int num) {
        curr = head;
 
        if(curr == NULL) {
            printf("Link List is empty");
        }
        else
        {
            while(curr != NULL) {
                
                if(curr->data == num) {
 
                    if(curr == head) {
                    head = curr->next;
                    free(curr);
                    break;
                }
                    left->next = curr->next;
                    free(curr);
                    break;
                }
                else {
                    left = curr;
                    curr = curr->next;
                }
            } //while loop
        }
    }
void disp() {
        if(head == NULL) {
            printf("Link list is empty");
            return;
        }
        else { 
            curr = head;
                
                while(curr != NULL) {
                    printf("%d ->  ",curr->data);
                    curr = curr->next;
                } //while
            }//else
        }
 void deleteAll() {
        curr = head;
        if(curr == NULL) {
          //  printf("Link list is empty");
        }
        else {
            while(curr != NULL) {
                left = curr->next;
                free(curr);
                curr = left;
            }
            head = NULL;
           // printf("Deleted Link list");
        }
    }





//Queue implementation

void enQueue(int value)
{
   if(rear == SIZE-1)
        printf("\nQueue is Full!!");
    else {
        if(front == -1)
            front = 0;
        rear++;
        items[rear] = value;
        printf("\nInserted -> %d", value);
    }
}
void deQueue(){
    if(front == -1)
        printf("\nQueue is Empty!!");
    else{
        printf("\nDeleted : %d", items[front]);
        front++;
        if(front > rear)
            front = rear = -1;
    }
}  

void display(){
    if(rear == -1)
        printf("\nQueue is Empty!!!");
    else{
        int i;
        printf("\nQueue elements are:\n");
        for(i=front; i<=rear; i++)
            printf("%d\t",items[i]);
    }
}
